{
  "hash": "26d05703f0abca6bdfe6119d0f431965",
  "result": {
    "markdown": "---\ntitle: Kildomaten\nfreeze: true\nexecute:\n    echo: false\n    include: true\n---\n\n::: {.cell execution_count=1}\n\n::: {.cell-output .cell-output-stdout}\n```\nSist endret: 2024-04-11\n```\n:::\n:::\n\n\n*Kildomaten* er en tjeneste for å automatisere overgangen fra [kildedata](./datatilstander.html#kildedata) til [inndata](./datatilstander.html#inndata). Tjenesten lar statistikkere kjøre sine egne skript automatisk på alle nye filer i kildedatabøtta og skrive resultatet til produktbøtta. Formålet med tjenesten er minimere behovet for tilgang til kildedata samtidig som teamet selv bestemmer hvordan transformasjonn til inndata skal foregå. Statistikkproduksjon kan da starte i en tilstand der dataminimering og pseudonymisering allerede er gjennomført.  \n\nProsessering som skal skje i overgangen fra kildedata til inndata har SSB definert til å være:\n\n- **Dataminimering**:  \nFjerne alle felter som ikke er strengt nødvendig for å produsere statistikk.\n- **Pseudonymisering**:  \nPseudonymisering av personidentifiserende data.\n- **Kodeverk**:  \nLegge på standard kodeverk fra for eksempel [Klass](https://www.ssb.no/klass/).  \n- **Standardisering**:  \nTegnsett, datoformat, etc. endres til SSBs standardformat.\n\nUnder forklarer vi nærmere hvordan man bruker tjenesten. Da forutsetter vi at du har et Dapla-team med tjenesten er aktivert. les mer om hvordan du aktiverer tjenester her (lenker her).\n\n## Forberedelser\n\nFør et Dapla-team kan ta i bruk *Kildomaten* må man tjenesten aktivert for teamet. Som standard får alle statistikkteam dette skrudd på i **prod**-miljøet som opprettes for teamet. Ønsker du å aktivere *Kildomaten* i **test**-miljøet kan dette gjøres selvbetjent som en [feature](./features.html). Alternativt kan man opprette en [Kundeservice](https://ssb.pureservice.com/#/categories/14/new)-sak og be om å hjelp til dette. \n\n## Sette opp tjenesten\n\nI denne delen bryter vi ned prosessen med å sette opp *Kildomaten* i de stegene vi mener det er hensiktsmessig å gjøre det når den settes opp for første gang på en enkeltkilde. Senere i kapitlet forklarer vi hvordan man setter den opp flere kilder og hvordan man vedlikeholder tjenesten. \n\nHusk at alle på teamet kan gjøre det meste av arbeidet her, men det er **data-admins** som må godkjenne at [tjenesten rulles ut](./kildomaten.html#rull-ut-tjenesten)^[I tillegg er det **data-admins** som må [teste tjenesten](./kildomaten.html#test-koden) manuelt hvis det gjøres på skarpe data, siden det kun er data-admins som kan få tilgang til de dataene.].\n\n### Klone IaC-repoet\n\nOppsett av *Kildomaten* gjøres i teamets *IaC*-repo^[*Infrastructure-as-Code* (*IaC*) er repo som definerer alle ressursene til teamet på Dapla. Alle Dapla-team har et eget IaC-repo på GiHub og du finner det ved å søke etter repoet <teamnavn>-iac under [statisticsnorway](https://github.com/orgs/statisticsnorway/repositories).]. Når vi skal sette opp *Kildomaten*-kilde må vi gjøre gjøre endringer i teamets IaC-repo. Man finner teamets IaC-repo ved gå inn på [SSBs GitHub-organisasjon](https://github.com/statisticsnorway) og søke etter repoet som heter `<teamnavn>-iac`. Når du har funnet repoet så kan du gjøre følgende:\n\n1. Klon ned ditt teams Iac-repo `git clone <repo-url>`\n2. Opprett en ny branch: `git checkout -b add-kildomaten-source`\n\n### Mappestruktur i IaC-repo\n\nFor at *Kildomaten* skal fungere så må det opprettes en bestemt mappestruktur i IaC-repoet til teamet. Når et team blir opprettet vil den grunnleggende mappestrukturen i IaC-repoet allerede være opprettet for **prod**-miljøet til teamet. F.eks. vil mappestrukturen se slik ut for team **dapla-example**:\n\n```{.yaml filename=\"github.com/statisticsnorway/dapla-example-iac\"}\ndapla-example-iac\n├── automation/\n│   └── source-data/\n│       ├── dapla-example-prod/\n│           └── README.md\n│ \n│...           \n```\n\nSkal du sette opp Kildomaten i prod-miljøet så kan du følge oppskriften som kommer senere i kapitlet uten å gjøre noe mer enda. \n\nSkal du også bruke Kildomaten i **test**-miljøet så må opprette en ny mappe og lage en PR i IaC-repoet til teamet. Da vil strukturen se slik ut:\n\n\n```{.yaml filename=\"github.com/statisticsnorway/dapla-example-iac\"}\ndapla-example-iac\n├── automation/\n│   └── source-data/\n│       ├── dapla-example-prod/\n│       │    └── README.md\n│       ├── dapla-example-test/ \n│...           \n```\n\nI mappestrukturen over så har vi klargjort den grunnleggende mappestrukturen for å ta i bruk Kildomaten i prod- og test-miljøet. Neste steg blir å legge de ulike kildene som egne mapper under `dapla-example-prod` og `dapla-example-test`. Det viser vi i neste avsnitt. \n\n### Flere kilder\n\nKildomaten lar deg prosessere ulike filstier i kildebøtta med ulike python-script. Dette refereres til som at Kildomaten har flere *kilder*. For å sette opp en kilde så må man følge en definert mappestruktur i IaC-repoet der alle kildene ligger rett under `<teamnavn>-prod`- eller `<teamnavn>-test`-mappen. Du kan ikke ha undermapper under en kilde. Du velger selv navnet på kildene/mappene i IaC-repoet, og det vil være navnet på kildene i Kildomaten. Senere i kapitlet ser vi at vi må bruke navnet for trigge re-kjøring av kilder. \n\nUnder er et eksempel på hvordan det kan se ut for eksempel-teamet dapla-example:\n\n```{.yaml filename=\"github.com/statisticsnorway/dapla-example-iac\"}\ndapla-example-iac\n├── automation/\n│   └── source-data/\n│       ├── dapla-example-prod/\n│       │    └── altinn\n│       │    └── ameld\n│       ├── dapla-example-test/\n│       │    └── altinn\n│       │    └── ameld\n│       │    └── nudb\n│...           \n```\n\nI eksempelet over ser vi at det er opprettet kildene *altinn* og *ameld* for både test- og prod-miljøet. I tillegg er det i test-miljøet kjørende en annen kilde som heter *nudb*. Hver av disse kildene kan kjøre et eget Pyton-script på alle filer som skrives til en gitt filsti som man definerer selv. \n\n::: {.callout-important}\n# Alle kilder på samme nivå\nEt team kan sette opp mange kilder som skal prosesseres med ulike skript. Men *Kildomaten* tillater bare et nivå under `automation/source-data-<teamnavn>-<miljø>/`. Det vil si at du ikke kan ha undermapper under en kilde. Det er også slik at man alltid må opprette en mappe for en kilde, selv om du kun har en kilde. F.eks. kan man ikke droppe mappen `altinn` i eksempelet over.  \n:::\n\n### Konfigurasjon og skript\n\nNår mappestrukturen er opprettet kan man legge til filene som beskriver hvilke filer som skal prosesseres, og python-skriptet med koden som skal prosessere filene. Det er to filer som må eksistere for at tjenesten skal fungere:\n\n1. En konfigurasjonsfil\n2. Et Python-skript\n\nNår du har opprettet de skal de ligge på denne måten i IaC-repoet:\n\n```{.yaml filename=\"github.com/statisticsnorway/dapla-example-iac\"}\ndapla-example-iac\n├── automation/\n│   └── source-data/\n│       ├── dapla-example-prod/\n│           └── altinn/\n│               ├── config.yaml\n│               └── process_source_data.py\n│...           \n```\nUnder forklares hvordan skriver innholdet i de to filene. \n\n#### Konfigurasjonsfil\n\n*Kildomaten* trigges ved at det oppstår nye filer i kildebøtta til teamet. Hvorvidt den skal trigges på alle filer, eller kun filer i en gitt undermappe, bestemmer brukeren ved å konfigurere tjenesten i `config.yaml`. Her kan du også angi hvor mye ressurser prosesseringen skal få.\n\nHvis vi fortsetter eksempelet vårt fra tidligere med `dapla-example`, så kan vi tenkes oss at teamet ønsker å Kildomaten skal trigges på alle filer som oppstår i kildebøtta under filstien:  \n`ssb-dapla-example-data-kilde-prod/ledstill/altinn/`.\n\nFor å konfigurere tjenesten i Kildomaten må vi legge til en fil som heter `config.yaml` under `automation/source-data/dapla-example-prod/altinn/`, slik som vist i forrige kapitel. I dette tilfellet vil den ha innholdet som vist til venstre under:  \n\n:::: {.columns}\n\n::: {.column width=\"47.5%\"}\n```{.yaml filename=\"config.yaml\"}\nfolder_prefix: ledstill/altinn\nmemory_size: 1  # GiB\n```\n:::\n\n::: {.column width=\"5%\"}\n<!-- empty column to create gap -->\n:::\n\n::: {.column width=\"47.5%\"}\n```{.yaml filename=\"ssb-dapla-example-data-kilde-prod/\"}\n├── ledstill/\n│   └── altinn/\n│   └── aordningen/\n├── sykefra/\n│   └── altinn/\n│   └── freg/\n│...\n       \n```\n:::\n\n::::\n\n\nMappestrukturen til høyre over viser hvordan vi mappestrukturen ser ut i kildebøtta, mens `config.yaml`-fila til venstre viser hvordan vi angir at *Kildomaten* kun skal trigges på nye filer som oppstår i undermappen `ssb-dapla-example-data-kilde-prod/ledstill/altinn/`. Vi bruker nøkkelen `folder_prefix` for å angi hvilken sti i kildebøtta som tjenesten skal trigges på. Nøkkelen `memory_size` lar brukeren angi hvor mye minne og CPU hver prosessering skal få.   \n\n::: {.callout-note}\n# Hvor mye minne og CPU er mulig?\nSom standard så får hver prosessering med *Kildomaten* 1 CPU-kjerne og 512MB minne/RAM. Hvis man skal gjøre mye prossesering, eller filene som prosesseres er veldig store, kan man sette `memory_size` opp til max 32GB minne. Antall CPU-kjerner blir satt implisitt ut i fra valg av `memory_size` iht til [begrensningene som Google setter for Cloud Run](https://cloud.google.com/run/docs/configuring/services/memory-limits#cpu-minimum). Se de [nøyaktige verdiene](https://github.com/statisticsnorway/terraform-dapla-source-data-processor/blob/b7655776258c79a91e97dd0da4c5c1e6f3631796/modules/processor-instance/locals.tf#L2) som blir satt her. \n:::\n\n#### Python-skript\n\n::: {.callout-important}\n# Husk dette når du skriver skriptet ditt\nNår du skal skrive et Python-skript for Kildomaten er det spesielt viktig å huske på 2 ting:\n\n1. Skriptet ditt kommer til å bli kjørt på en-og-en fil. \n2. Skriptet ditt må skrive ut et unikt navn på filen som skal skrives til produktbøtta, ellers risikerer du at filer blir overskrevet.\n3. Python-pakkene som kan benyttes [er definert her](https://github.com/statisticsnorway/dapla-source-data-processor/blob/main/requirements.txt). Ved behov for andre pakker, [ta kontakt med Kundeservice](https://ssb.pureservice.com/#/categories/14/new).  \n:::\n\nPython-skriptet er der teamet kan angi hva slags kode som skal kjøre på hver fil som dukker opp i den angitte mappen i kildebøtta. For at dette skal være mulig må koden følge disse reglene:\n\n1. Koden må ligge i en fil som heter `process_source_data.py`. \n2. Koden må pakkes inn i en funksjon som heter `main()`. \n\n`main()` er en funksjon med ett parameter som heter `source_file` som du alltid får av *Kildomaten* når en fil blir prosessert. Når du skriver koden kan man derfor anta at dette parameteret blir gitt til funksjonen, og du kan benytte det inne i `main`-funksjonen. \n\n`source_file`-parameteret gir `main()` en ferdig definert filsti til filen som skal prosesseres. For eksempel så kan `source_file` ha verdien  \n`gs://ssb-dapla-example-data-kilde-prod/ledstill/altinn/test20231010.csv` hvis filen `test20231010.csv` dukker opp i `ssb-dapla-example-data-kilde-prod/ledstill/altinn/`. \n\nHvis vi fortsetter eksempelet fra tidligere så ser mappen i IaC-repoet vårt slik ut nå: \n\n```{.yaml filename=\"github.com/statisticsnorway/dapla-example-iac\"}\n├── automation/\n│   └── source-data/\n│       ├── dapla-example-prod/\n│           └── altinn/\n│               ├── config.yaml\n│               └── process_source_data.py\n│\n│...         \n```\n\nVi ser nå at filene `config.yaml` og `process_source_data.py` ligger i mappen  \n`automation/source-data/dapla-example-prod/ledstill/altinn/`. Senere, når vi har rullet ut tjenesten, vil en ny fil i `gs://ssb-dapla-exmaple-data-kilde-prod/ledstill/altinn/` trigge *Kildomaten* og kjøre koden i `process_source_data.py` på filen. \n\nUnder ser du et eksempel på hvordan en vanlig kodesnutt kan konverteres til å kjøre i *Kildomaten*:\n\n:::: {.columns}\n\n::: {.column width=\"47%\"}\n```{.python filename=\"Vanlig kode\"}\nimport dapla as dp\n\n# Stien til filen\nsource_file = \"gs://ssb-dapla-example-data-kilde-prod/ledstill/altinn/test20231010.csv\"\n\ndf = dp.read_pandas(source_file, file_type=\"csv\")\n\n# Dataminimerer ved å velge kolonner\ndf2 = df[['col1', 'col2', 'col3']]\n\n# Skriver ut fil til produktbøtta\ndp.write_pandas(df2, \n            \"gs://ssb-dapla-example-data-produkt-prod/test20231010.parquet\")\n```\n\n       \n:::\n\n::: {.column width=\"6%\"}\n\n:::\n\n::: {.column width=\"47%\"}\n\n```{.python filename=\"Kode i Kildomaten\"}\nimport dapla as dp\n\ndef main(source_file):\n    df = dp.read_pandas(source_file, file_type=\"csv\")\n\n# Dataminimerer ved å velge kolonner\n    df2 = df[['col1', 'col2', 'col3']]\n\n# Bytter ut \"kilde\" med \"produkt\" i filstien\n    new_path = source_file.replace(\"kilde\", \"produkt\")\n\n# Bytter ut \".csv\" med \".parquet\" i filstien\n    new_path2 = new_path.replace(\".csv\", \".parquet\")\n\n# Skriver ut fil til produktbøtta\n    dp.write_pandas(df2, new_path2)\n\n```\n:::\n\n\n::::\n\nDe to kodesnuttene over gir det samme resultatet, bare at koden til venstre kjøres som vanlig python-kode, mens koden til høyre kjøres i *Kildomaten*. Som vi ser av koden til høyre så trenger vi aldri å hardkode inn filstier i Kildomaten. Tjenesten gir oss filstien, og vi kan bruke den til å skrive ut filen til produktbøtta. \n\nStrukturen på filene som skrives bør tenkes nøye gjennom når man automatiseres prosessering av data. Hvis vi ikke har unike filnavn eller stier så kan du risikere at filer blir overskrevet. Typisk er dette allerede tenkt på når filer skrives til kildebøtta, så hvis man kopierer den strukturen, slik vi gjorde i eksempelet over, så vil det ikke være noe problem.\n\n::: {.callout-note}\n# Hvilke Python-biblioteker kan jeg bruke?\nDu kan kun bruke biblioteker som er forhåndsinstallert i Kildomaten. Du kan se en [liste over disse bibliotekene her](https://github.com/statisticsnorway/dapla-source-data-processor/blob/main/requirements.txt). Ønsker du andre biblioteker så må du ta kontakt med Kunderservice.\n:::\n\n### Test koden\n\n::: {.callout-note}\n# Tilgang til kildedata\nTilgang til kildedata i prod-miljøet er det kun gruppen **data-admins** som kan aktivere ved å bruke tilgangsstyringsløsningen [Just-in-Time Access (JIT)](https://jitaccess.dapla.ssb.no/). Les mer om hvordan [JIT-løsningen fungerer her](./jit.html). Ønsker man å kunne liste ut innhold fra bøtta må man aktivere rollen `ssb.buckets.list`. Ønsker man i tillegg å lese/skrive til bøtta må man også aktivere `ssb.bucket.write`. Tilgang til kildebøtta i test-miljøet krever ikke JIT-tilgang. \n:::\n\nFør man ruller ut koden i tjenesten er det greit å teste at alt fungerer som det skal i Jupyterlab. Hvis vi tar utgangspunkt i eksempelet over så kan vi teste koden ved å kjøre følgende nederst i skriptet:\n\n```{.python filename=\"process_source_data.py\"}\nmain(\"gs://ssb-dapla-example-data-kilde-prod/ledstill/altinn/test20231010.csv\")\n```\n\nNår tjenesten er rullet ut så vil det være dette som kjøres når en fil dukker opp i `gs://ssb-dapla-example-data-kilde-prod/ledstill/altinn/`. Ved å kjøre det manuelt på denne måten får vi sett at ting fungerer som det skal. \n\nHusk å fjerne kjøringen av koden før du ruller ut tjenesten. \n\n::: {.callout-note}\n# Pseudonymisering kan **ikke** kjøres fra en IDE i prod-miljøet\nDu kan teste kode fra Jupyter og andre IDE-er i prod-miljøet på Dapla. Men hvis prosesseringen innebærer bruk av pseudonymisering, så vil den ikke kunne kalles fra programmeringsmiljøer som Jupyter. Grunnen til dette er at det ikke er ønskelig å gjøre det lett å se upseudonymisert og pseudonymisert data samtidig. Hvis du ønsker å teste prosesseringen av pseudo-tjenesten, så kan du gjøre med testdata i test-miljøet. \n:::\n\n### Rull ut tjenesten\n\nFor å rulle ut tjenesten gjør du følgende;\n\n1. *Push branchen* til GitHub og opprette en *pull request*. \n2. *Pull request* må godkjennes av en **data-admins** på teamet.\n\n::: {.grid}\n\n::: {.g-col-4}\n3. Når *pull request* er godkjent så sjekker du om alle tester, planer og utrullinger var vellykket, slik som vist i @fig-passing-checks.\n4. Hvis alt er vellykket så kan du *merge* branchen inn i `main`-branchen.\n\n:::\n\n::: {.g-col-8}\n![Suksessfulle tester på GitHub](../images/checks_passed.png){fig-alt=\"Suksessfulle tester på GitHub\" #fig-passing-checks}\n\n:::\n\n:::\n\n\nEtter at du har *merget* inn i *main* kan du følge med på utrullingen under *Actions*-fanen i repoet. Når den siste jobben lyser grønt er Kildomaten rullet ut og klar til bruk.\n\n::: {.callout-note}\n# Vanlige feil ved utrulling\nFor å gi raskt tilbakemelding på noen mulige feilsituasjoner, så kjøres det enkel validering på `config.yaml` og `process_source_data.py` når en *Pull request* er opprettet. Følgende validering gjennomføres:\n\n- Er det et python-script kalt `process_source_data.py`?\n- Er det en `config.yaml` med en gyldig `folder_prefix:` definert?\n- Bruker `process_source_data.py` biblioteker som ikke [er installert i Kildomaten](https://github.com/statisticsnorway/dapla-source-data-processor/blob/main/requirements.txt)?\n- Har koden i `process_source_data.py` feil iht [Pyflakes](https://pypi.org/project/pyflakes/)?\n\nDet kan også forekomme at **Atlantis**, verktøyet for å rulle ut endringer fra IaC-repoet til GCP, feiler. Da kan du prøve å skrive `atlantis plan` i kommentarfeltet til *pull request*'en, og testene vil kjøre på nytt. Hvis det fortsatt ikke fungerer så kontakter man Dapla kundeservice. \n:::\n\n### Test tjenesten\n\nNår du har rullet ut tjenesten kan *teste* tjenesten ved at **data-admins** flytter en fil til en den filstien *Kildomaten* er satt opp for. I eksempelet vi har brukt tidligere, gjør du følgende:\n1. Aktiverer JIT-tilgangen til kildedata (som beskrevet over).\n2. Kopier en fil over til filstien:  \n`gs://ssb-dapla-example-data-kilde-prod/ledstill/altinn/`\n3. Sjekk om filen ble skrevet til ønsket mappe i produktbøtta.\n\nDu kan også sjekke logger og monitorere *Kildomaten*. Les mer i neste avsnitt.\n\n### Monitorering og logging\n\nNår en kilde i *Kildomaten* er satt opp og ruller ut, kan du monitere tjenesten i Google Cloud Console (GCC) ved å gjøre følgende:\n\n1. [Logg deg inn](https://console.cloud.google.com/) med SSB-bruker på GCC.\n2. Velg standardprosjektet i prosjektvelgeren^[Standardprosjektet har navnestrukturen `<teamnavn>-p`].\n3. Søk opp **Cloud Run** i søkefeltet på toppen av siden og gå inn på siden. \n\nPå siden til **Cloud Run** vil du se en oversikt over alle kilder teamet har kjørende i *Kildomaten*. De har formen `source-<kildenavn>-processor`. I eksempelet med team **dapla-example** tidligere, vil man da se en kilde som heter `source-altinn-processor`, siden mappen de opprettet under  \n`automation/source-data-dapla-example-prod/` i IaC-repoet heter `altinn`. \n\nTrykker man seg inn på hver enkelt kilde vil man kunne monitorere aktiviteten i kilden, og man kan trykke seg videre for å se loggene.\n\n::: {.callout-note}\n# Sjekke logger\nDet er anbefalt å se på Kildomaten-loggene i Logs Explorer. Det kan man enkelt gjøre ved å trykke på \"View in Logs Explorer\" som vist på bildet under:\n\n![Åpne Kildomaten-loggene i Logs Explorer](../images/kildomaten-logger.png){ fig-alt=\"Bilde som viser hvordan man åpner Logs Explorer\" width=100% }\n:::\n\n### Skalering\n\n*Kildomaten* er satt opp for å kunne prosessere hver kilde i 5 parallelle intanser samtidig. F.eks. hvis det oppstår 10 nye filer i en mappe som trigger en *Kildomaten*-kilde, så kan det prosesseres 5 filer samtidig. [Ta kontakt med Kundeservice](https://ssb.pureservice.com/#/categories/14/new) hvis man har behov for ytterlige skalering.  \n\n### Varsling på e-post\n\nKildomaten tilbyr e-postvarsling til teamet når tjenesten feiler. Opprett en Kundeservice-sak for å få satt opp e-postvarsling for teamet ditt.\n\n### Flere kilder\n\nMan kan sette opp så mange kilder man ønsker. Men når man setter det opp er det viktig å huske at alle kildene må spesifiseres rett under `automation/source-data/<teamnavn>-<miljø>/`. Her er et eksempel på hvordan team **dapla-example** har to kilder i *Kildomaten*:\n\n```{.yaml filename=\"github.com/statisticsnorway/dapla-example-iac\"}\ndapla-example-iac\n├── automation/\n│   └── source-data/\n│       ├── dapla-example-prod/\n│           └── altinn/\n│               ├── config.yaml\n│               └── process_source_data.py\n│           └── ledstill/\n│               ├── config.yaml\n│               └── process_source_data.py\n│...           \n```\n\nI eksempelet over ser vi det er to kilder: `altinn` og `ledstill`. Hver kilde trigges på ulike filstier i kildebøtta, og python-koden som kjøres kan være ulik mellom kilder. \n\n### Test-miljø\n\nI eksempelet som er brukt i dette kapitlet er Kildomaten satt opp i prodmiljøet til teamet. Mens egentlig burde man teste ut nye kilder i teamets test-miljø. Kildomaten er ikke satt opp i test-miljøet som standard, og derfor må det skrus på før man kan anvende det. Teamet kan gjøre det selv [ved å følge denne beskrivelsen](./features.html), eller de kan ta kontakt med Kundeservice og få hjelp til dette. \n\nEn av de store fordelene med å sette opp *Kildomaten*-kilder i test-miljøet før man gjør det i prod-miljøet, er at tilgangsstyringen til data er mye mindre streng. Det gjør det lettere for alle i teamet å utvikle koden som skal benyttes. \n\nNår man skal sette opp *Kildomaten* i test-miljøet så følger det samme oppskrift som vi har vist for prod-miljøet over. Den store forskjellen er at test-kilder skal legges under en egen mappe under  `automation/source-data/` i teamets IaC-repo. Eksempelet under med team **dapla-example** viser hvordan man kan sette opp kildene `altinn` og `ledstill` for både prod- og test-testmiljøet:\n\n```{.yaml filename=\"github.com/statisticsnorway/dapla-example-iac\"}\ndapla-example-iac\n├── automation/\n│   └── source-data/\n│       ├── dapla-example-prod/\n│       │       ├── altinn/\n│       │       │       ├── config.yaml\n│       │       │       └── process_source_data.py\n│       │       └── ledstill/\n│       │               ├── config.yaml\n│       │               └── process_source_data.py\n│       ├── dapla-example-test/\n│               ├── altinn/\n│               │       ├── config.yaml\n│               │       └── process_source_data.py\n│               └── ledstill/\n│                       ├── config.yaml\n│                       └── process_source_data.py\n│...           \n```\n\nSom vi ser av mappestrukturen over så er det to mapper under  \n`automation/source-data`:\n\n- dapla-example-prod\n- dapla-example-test\n\nDisse to mappene angir om det er henholdsvis prod- eller test-miljøet vi setter opp kilder for. \n\n\n### Trigge kilde manuelt\n\nKildomaten er bygget for å trigge på nye filer som oppstår i en gitt filsti. Men noen ganger er det nødvendig å trigge kjøring av alle filer på nytt. Noen ganger ønsker man kanskje å kun trigge noen filer for en gitt kilde. Dette kan gjøres med en funksjon i Python-pakken [dapla-toolbelt](https://github.com/statisticsnorway/dapla-toolbelt).\n\nFør du kan gjøre dette trenger du følgende informasjon:\n\n1. **project-id** for *standardprosjektet*. [Slik finner du prosjekt-id](../faq.qmd#hvordan-finner-jeg-et-google-prosjekt-sin-prosjekt-id). Merk at dette ikke er kilde-prosjektet!\n2. **folder_prefix** som du ønsker at koden skal trigges på. Dette fungerer likt som tidligere forklart for `config.yaml`, men her har du også mulighet til å kunne trigge prosesseringen på et undermappe av stien som var satt i kildens config.yaml.\n3. **source_name** er navnet på kilden. Navnet på kilden i eksempelet med team **dapla-example** var  `altinn`. \n\nHer er et kodeeksempel som viser hvordan man kan trigge prossesering av alle filer for kilde\n\n```{.python filename=\"notebook\"}\nfrom dapla import trigger_source_data_processing\n\nproject_id = \"dapla-example-p\"\nsource_name = \"altinn\"\nfolder_prefix = \"ledstill/altinn/ra0678\"\n\ntrigger_source_data_processing(project_id, source_name, folder_prefix, kuben=True)          \n```\n\nI eksempelet over trigger vi scriptet som er satt opp for kilden `altinn` til å kjøre på alle undermapper av  \n`ssb-dapla-example-data-kilde-prod/ledstill/altinn/ra0678/`. \n\n## Vedlikehold\n\nNår tjenesten er rullet ut så vil den kjøre automatisk på alle filer som dukker opp i filsti i kildebøtta. Etter hvert vil det være behov for å endre på skript, endre filstier som skal trigge tjenesten, eller prosessere alle filer på nytt. I denne delen forklarer vi hvordan du går frem for å gjøre dette. \n\n### Endre skript\n\nAlle på team kan endre på skriptet, men det er **data-admins** som må godkjenne endringene før de blir rullet ut. For å endre skriptet gjør du følgende:\n\n1. Klon repoet.\n2. Gjør endringene du ønsker i en *branch*.\n3. Push opp endringene til GitHub og opprett en *pull request*.\n4. Få en data-admins på teamet til å godkjenne endringene.\n5. Når endringene er godkjent så kan du *merge* inn i `main`-branchen.\n\nEn endring i Python-skriptet krever ikke at tjenesten rulles ut på nytt. Derfor er det ikke like mange tester og kjøringer som gjøres som når man oppretter en helt ny kilde. \n\n### Endre config.yaml\n\nAlle på teamet kan gjøre endringer i `config.yaml`, men det er **data-admins** som må godkjenne endringene før de blir rullet ut. For å endre `config.yaml` gjør du følgende:\n\n1. Klon repoet.\n2. Gjør endringene du ønsker i en *branch*.\n3. Push opp endringene til GitHub og opprett en *pull request*.\n4. Få en data-admins på teamet til å godkjenne endringene.\n5. Når endringene er godkjent så kan du *merge* inn i `main`-branchen.\n\nEn endring i config.yaml krever at tjenesten rulles ut på nytt og tar derfor litt mer tid enn en endring i Python-skriptet.\n\n",
    "supporting": [
      "kildomaten_files"
    ],
    "filters": [],
    "includes": {}
  }
}