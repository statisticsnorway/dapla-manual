{
  "hash": "9263d690a6b55f419558f06afa156bd0",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Intro til Pandera\nsubtitle: Data validering i kode med Pandera.\ncategories:\n  - Data validering\n  - Python\n  - Pandera\nauthor:\n  - name: Jonathan Husø\n    affiliation:\n      - name: Seksjon for Utenrikshandelsstatistikk (214)\n        email: jhu@ssb.no\nimage: Pandera-Python-package.png\nimage-alt: Logo til Pandera\ndate: 12/16/2024\ndate-modified: 12/16/2024\nfreeze: true\ndraft: false\n---\n\n[Pandera](https://pandera.readthedocs.io/en/stable/index.html#) er en python pakke og rammeverk for testing av data, eller som bedre definert som data validering.\nTester kan gjerne bli misforstått mellom statistikker og utvikler, hvor en statistikker tenker på tester som testing av data, og utvikler tenker på tester som testing av kode.\nNår det kommer til Python, så bruker vi i SSB som oftest [Pytest](https://docs.pytest.org/en/stable/) pakken for testing av kode, og Pandera eller [Pydantic](https://docs.pydantic.dev/latest/) pakkene for data validering.\nAlle disse pakkene står oppført på [godkjentlista](https://statistics-norway.atlassian.net/wiki/spaces/Arkitektur/pages/3538355352/Godkjentliste+for+statistikkproduksjon+p+Dapla#Enhetstester,-objektmodeller-og-milj%C3%B8variabler) i SSB. Hvem av Pandera og Pydantic som bør benyttes avhenger mest av strukturen på dataene din.\nDersom dataene er semi-strukturert (ofte filformater som json og xml) så vil fort Pydantic være mest aktuell, mens er dataene strukturerte (som en dataframe, eller filformat som csv) så vil Pandera være ett mer naturlig valg. Her vil det gis en intro til Pandera. Vel og merke vil innholdet her dreie seg om grunnleggende bruk, samt forskjellige tips og triks i hvordan det kan brukes, og muligens en bonus til slutt. Mer avanserte temaer, som f.eks. hypotesetesting, er ikke med her.\n\nMen hvorfor Pandera? Og hvorfor validere data? Siste er vel enkelst å besvare, og ligger jo godt integrert i SSBs samfunnsansvar: Vi skal ha god kvalitet i all statistikk, forskning og analyse. I den moderniserings prosessen SSB er i, med overgang til Dapla, så er det naturlig at dette integreres i kodene våre, og da er data valideringspakker som Pandera høyst aktuell. I tillegg er det en [anbefaling fra KVAKK](https://statistics-norway.atlassian.net/wiki/spaces/BEST/pages/3041492993/Regler+og+anbefalinger+for+versjonskontroll+med+Git#A-011-Anbefaling:-Produksjonskode-skal-som-standard-v%C3%A6re-%C3%A5pen-kildekode.-Det-vil-si-at-git-repoene-skal-v%C3%A6re-public.), og en [ADR](https://statistics-norway.atlassian.net/wiki/spaces/Arkitektur/pages/4248731934/ADR0006+-+Retningslinjer+for+pen+intern+og+lukket+kildekode+i+SSB) vedtatt i SSB, om at kildekode skal være offentlig tilgjengelig. Så en eller annen gang skal produksjonskoden vår, som lager statistikkene, bli offentlig tilgjengelig. Dette er kanskje mine personlige meninger rundt det, men jeg vil tro at det vil foreligge en stor forventning der ute om at SSB validerer data i kode. Selv om Pandera er relativt nytt, så støtter den de aller mest brukte dataframe rammeverkene som er i bruk i SSB, slik som Pandas, Polars, og PySpark.\n\n## Import og testdata\n\nFørst så importerer vi noen biblioteker som vi skal benytte. For å benytte Pandera pakken må det lastes inn til ett virtuelt miljø, som vi i SSB benytter [ssb-project](../../../statistikkere/jobbe-med-kode.qmd#dapla-toolbelt) for;\n\n``` {.bash filename=\"terminal\"}\npoetry add pandera\n```\n\nVersjonen av Pandera som benyttes i introduksjonen her er **0.20.4**. Følgende pakker får jeg importert deretter;\n\n::: {#b8bd0251-224d-4f48-95a5-5e8d2bf57a55 .cell execution_count=1}\n``` {.python .cell-code}\nimport uuid\nfrom typing import Dict\nimport pandas as pd\nimport numpy as np\nimport pandera as pan\nfrom pandera.typing import DataFrame, Series\nfrom pandera.errors import SchemaErrors\n```\n:::\n\n\nJeg lager også følgende lekedata vi skal ta for oss i eksemplene;\n\n::: {#45e6a416-29c0-4fcb-9344-51cc807ab5ea .cell execution_count=2}\n``` {.python .cell-code}\nsize = 6\n\nrandom_data = pd.DataFrame({\n    \"id_nr\": [str(uuid.uuid4()) for _ in range(size)],\n    \"lope_id_nr\": [\"L\" + str(1).zfill(4) for _ in range(size)],\n    \"aar\": np.random.choice(['2023', '2024'], size),\n    \"navn\": np.random.choice(['Ola', 'Kari', 'Per', 'Ida'], size),\n    \"produkt\": np.random.choice(['Eple', 'Gulrot', 'Brokkoli'], size),\n    \"salgsverdi\": np.random.randint(1000, 10000, size),\n    \"vekt\": np.random.randint(500, 5000, size)\n})\n\nrandom_data['kostverdi'] = (\n    random_data['salgsverdi'] * 0.75\n).astype(int)\n\nbad_data = pd.DataFrame({\n    \"id_nr\": [\"random-id1\", \"random-id1\", \"random-id2\",\n              \"random-id2\", \"random-id3\"],\n    \"lope_id_nr\": [\"L0001\", \"L0002\", \"L0001\", \"L0001\", \"0001\"],\n    \"aar\": ['2023', '2023', '2024', '2024', '2024Q1'],\n    \"navn\": ['Ola', 'Ola', 'Per', 'Kari', None],\n    \"produkt\": ['Banan', 'Eple', 'Eple', 'Agurk', 'Eple'],\n    \"salgsverdi\": [5000, 4000, 7000, 3000, 50],\n    \"vekt\": [700, 600, 700, 100, 5],\n    \"kostverdi\": [3500, 2500, 5000, 3100, 55],\n})\n\ndata = pd.concat([random_data, bad_data], ignore_index=True)\ndata\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id_nr</th>\n      <th>lope_id_nr</th>\n      <th>aar</th>\n      <th>navn</th>\n      <th>produkt</th>\n      <th>salgsverdi</th>\n      <th>vekt</th>\n      <th>kostverdi</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>829c6ce1-817d-40f3-956d-dffb5cf9dbec</td>\n      <td>L0001</td>\n      <td>2024</td>\n      <td>Ida</td>\n      <td>Eple</td>\n      <td>2072</td>\n      <td>1420</td>\n      <td>1554</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>ed18c723-b1c8-49be-8017-aa6b9e1bbef7</td>\n      <td>L0001</td>\n      <td>2023</td>\n      <td>Ida</td>\n      <td>Eple</td>\n      <td>2624</td>\n      <td>2989</td>\n      <td>1968</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1306362a-df6b-4f66-bcbb-1f718a37a8e9</td>\n      <td>L0001</td>\n      <td>2023</td>\n      <td>Per</td>\n      <td>Eple</td>\n      <td>5751</td>\n      <td>1726</td>\n      <td>4313</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>d2667fa8-71c8-4987-8079-dd28d59f3a69</td>\n      <td>L0001</td>\n      <td>2024</td>\n      <td>Kari</td>\n      <td>Gulrot</td>\n      <td>9596</td>\n      <td>3500</td>\n      <td>7197</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>b925e792-8b16-45ce-8255-1741a9ecfb86</td>\n      <td>L0001</td>\n      <td>2023</td>\n      <td>Kari</td>\n      <td>Brokkoli</td>\n      <td>4986</td>\n      <td>2424</td>\n      <td>3739</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>999d897a-c2e0-4529-935e-956e74614463</td>\n      <td>L0001</td>\n      <td>2024</td>\n      <td>Kari</td>\n      <td>Brokkoli</td>\n      <td>5439</td>\n      <td>663</td>\n      <td>4079</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>random-id1</td>\n      <td>L0001</td>\n      <td>2023</td>\n      <td>Ola</td>\n      <td>Banan</td>\n      <td>5000</td>\n      <td>700</td>\n      <td>3500</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>random-id1</td>\n      <td>L0002</td>\n      <td>2023</td>\n      <td>Ola</td>\n      <td>Eple</td>\n      <td>4000</td>\n      <td>600</td>\n      <td>2500</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>random-id2</td>\n      <td>L0001</td>\n      <td>2024</td>\n      <td>Per</td>\n      <td>Eple</td>\n      <td>7000</td>\n      <td>700</td>\n      <td>5000</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>random-id2</td>\n      <td>L0001</td>\n      <td>2024</td>\n      <td>Kari</td>\n      <td>Agurk</td>\n      <td>3000</td>\n      <td>100</td>\n      <td>3100</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>random-id3</td>\n      <td>0001</td>\n      <td>2024Q1</td>\n      <td>None</td>\n      <td>Eple</td>\n      <td>50</td>\n      <td>5</td>\n      <td>55</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nSå raskt forklart har vi en dataframe med 11 rader. Kolonnene er da;\n\n- id_nr for ett slags identifiseringsnummer eller kvitteringsnummer om du vil\n- lope_nr_id som ett slags løpenummerid\n- aar for perioden i år som raden gjelder\n- navn for navn på enheten, som her er en person eller kunde om du vil\n- produkt for produktet det gjelder, vi kan si dette gjelder en frukt og grønt butikk\n- salgsverdi for slutt verdien det ble solgt for\n- vekt for slutt vekten som ble solgt\n- kostverdi for kostnaden tilknyttet innkjør av produktet eller varen.\n\nDet er elementer her som ikke nødvendigvis er fullt realistist med virkeligheten, men sammensetningen av disse kolonnene er mest bygd opp for å demonstrere mulighetene og fleksibiliteten ved bruk av pandera.\n\n## Grunnleggende bruk\n\nFor å ta i bruk pandera må vi definere et schema. Ett schema er en definering av hvordan dataene forventes at skal se ut, spesilt når det kommer til datatyper. Med pandera kan du definere både datatyper og innhold, og begge disse vil bli validert. Det er litt flere måter å definere ett schema på, men jeg kommer til å vise den kanskje mest anbefalte måten å gjøre det på. Den er kanskje ikke den mest enkleste, men den er enkel nok, og fordelen er at den har likheter til Pydantic.\n\nEt schema i pandera defineres som følgende;\n\n::: {#04ac3237-a51b-4c02-b63e-415ea52dcda7 .cell execution_count=3}\n``` {.python .cell-code}\nclass SchemaValidation1(pan.DataFrameModel):\n    \n    id_nr: Series[str] = pan.Field(unique=True)\n    lope_id_nr: Series[str] = pan.Field(\n        str_startswith='L',\n        str_length={'min_value': 5,\n                    'max_value': 5}\n    )\n    aar: Series[str] = pan.Field(\n        str_length={'min_value': 4,\n                    'max_value': 4}\n    )\n    navn: Series[str] = pan.Field(\n        nullable=False # Default\n    )\n    produkt: Series[str] = pan.Field(\n        isin=['Eple', 'Banan', 'Gulrot', 'Brokkoli']\n    )\n    salgsverdi: Series[int] = pan.Field(ge=1000)\n    vekt: Series[int] = pan.Field(ge=500)\n    kostverdi: Series[int] = pan.Field(gt=700)\n```\n:::\n\n\nSå hva er det vi har definert her? Vi har nå definert ett eget Objekt, en class, kalt SchemaValidation1, som arver egenskapene til Pandera sitt objekt DataFrameModel. Mer avansert fra objekt og class verden trenger du ikke å gjøre eller kunne her egentlig, så ikke bli skremt med det første. Deretter definerer vi kolonnene som vi forventer i dette schemaet. Pandera er bygget på typing systemet til Python vel og merke, som enklest forklart vil si at jeg kan bruke typing pakkens objekter i definisjonen som han vil bruke til å validere for, men det gir også muligheten til å benytte pythons stanard objektene som str og int  inne i definisjonen. Vi har også definert regler tilknyttet hver av disse kolonne som da vil bli validert sammen med datatypene.\n\n- id_nr er en Serie (kolonner i pandas dataframe er av datatypen pandas serie) med forventet datatype string (str). Regler som er satt er at innholde her er unike, altså ingen duplikater i de verdiene som ligger i kolonnen.\n- lope_id_nr er også forventet datatype string. Den har 2 regler; at alle verdier starter med 'L', og at teksten er minimum og maksimum 5 karakterer lang.\n- aar er forventet å være string, med regel om at den er 4 karakterer lang.\n- navn er forventet å være string, med regel om at det ikke skal være noen manglende verdier (missing values). Dette er egentlig standard satt for alle regler, så dette er ikke nødvendig å notere, men for demonstrasjonens skyld så gjorde jeg det her.\n- produkt er forventet å være string, med regler om at innholde er blant verdiene i en gitt liste. I dette tilfelle Eple, Banan, Gulrot, Brokkoli. Kanskje er dette varene butikken selger og har i sortimentet sitt.\n- salgsverdi er forventet å være en integer (int), som vil si tall uten desimaler. Regel som er satt her er at verdiene er større eller lik 1000.\n- vekt er forventet å være en integer. Regel som er satt her er at verdiene er større eller lik 500.\n- kostverdi er forventet å være en integer. Regel som er satt her er at verdiene er større enn 700.\n\nOkei, da har vi definert schemaet. Vi skal bygge videre på dette snart. Det finnes mange flere innebygde valideringsregler enn de vi benytter her, og man må inn i dokumentasjonen til Pandera for å se om noe kan passe deg og ditt behov der, men her demonstrerer vi hvertfall noen som sikkert kommer til å bli brukt.\n\nFor å utføre valideringen gjør vi følgende;\n\n::: {#99adee9d-0a12-4ade-bcc3-1f0bf85e0caa .cell execution_count=4}\n``` {.python .cell-code}\ntry:\n    valresult = SchemaValidation1.validate(data, lazy=True)\nexcept SchemaErrors as error:\n    # Rapport av feil utslag i dataframe\n    valresult = error.failure_cases\n    # Dataframe som ble sendt inn\n    errdata = error.data\n    # Antall feil utslag\n    num_errors = error.error_counts\n    # Rapportmeilding av feil utslag i dict\n    error_message = error.message\n\nvalresult\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>schema_context</th>\n      <th>column</th>\n      <th>check</th>\n      <th>check_number</th>\n      <th>failure_case</th>\n      <th>index</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Column</td>\n      <td>id_nr</td>\n      <td>field_uniqueness</td>\n      <td>None</td>\n      <td>random-id1</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Column</td>\n      <td>id_nr</td>\n      <td>field_uniqueness</td>\n      <td>None</td>\n      <td>random-id1</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Column</td>\n      <td>id_nr</td>\n      <td>field_uniqueness</td>\n      <td>None</td>\n      <td>random-id2</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Column</td>\n      <td>id_nr</td>\n      <td>field_uniqueness</td>\n      <td>None</td>\n      <td>random-id2</td>\n      <td>9</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Column</td>\n      <td>lope_id_nr</td>\n      <td>str_length(5, 5)</td>\n      <td>0</td>\n      <td>0001</td>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>Column</td>\n      <td>lope_id_nr</td>\n      <td>str_startswith('L')</td>\n      <td>1</td>\n      <td>0001</td>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>Column</td>\n      <td>aar</td>\n      <td>str_length(4, 4)</td>\n      <td>0</td>\n      <td>2024Q1</td>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>Column</td>\n      <td>navn</td>\n      <td>not_nullable</td>\n      <td>None</td>\n      <td>None</td>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>Column</td>\n      <td>produkt</td>\n      <td>isin(['Eple', 'Banan', 'Gulrot', 'Brokkoli'])</td>\n      <td>0</td>\n      <td>Agurk</td>\n      <td>9</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>Column</td>\n      <td>salgsverdi</td>\n      <td>greater_than_or_equal_to(1000)</td>\n      <td>0</td>\n      <td>50</td>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>Column</td>\n      <td>vekt</td>\n      <td>greater_than_or_equal_to(500)</td>\n      <td>0</td>\n      <td>100</td>\n      <td>9</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>Column</td>\n      <td>vekt</td>\n      <td>greater_than_or_equal_to(500)</td>\n      <td>0</td>\n      <td>5</td>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>12</th>\n      <td>Column</td>\n      <td>kostverdi</td>\n      <td>greater_than(700)</td>\n      <td>0</td>\n      <td>55</td>\n      <td>10</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nObjektet SchemaValidation1, som vi lagde, har en metode validate som vi kan sende inn dataframen som skal valideres opp mot schemaet(som vi arvet fra pandera DataFrameModel objektet). Jeg har satt lazy til True her fordi jeg vil at han skal validere alt og ikke stoppe ved første feil han finner. Dersom valideringen feiler så har pandera ett error objekt SchemaErrors hvor flere nyttige rapporter blir lagd tilgjengelig for oss. Du kan selv lege med flere av dem, men her tar vi for oss dataframen med alle feilmeldingene som dukker opp. Dersom valideringen gikk bra vil du få dataframen du sendte inn i retur.\n\nRapporten vi har fått ut nå i dataframen valresult har vi flere utslag på. Kolonnen id_nr finnes det duplikater blant annet. Kolonnen lope_id_nr er det funnes en som har slått ut i begge definerte reglene som nevnt tidligere. osv, osv. Denne rapporten har vi kanskje et potensial for å utnytte videre? Men det får være opp til den enkelte.\n\n## Behov for flere kontroller\n\nDersom de innebygde mulighetene for validering ikke strekker til, så kan man definere reglene selv ved å definere egne metoder med tilhørende decorator (alfakrøll over metoden). Under her definerer jeg SchemaValidation2, som er sett bort ifra de nye metodene nesten helt identisk med SchemaValidation1. forskjellen er at nå har kolonnen id_nr kun regelen om at den skal ikke ha manglende verdier i stedet for at det skal unike verdier.\n\n::: {#fb327f3b-ec50-474c-8ac9-fd7520093661 .cell execution_count=5}\n``` {.python .cell-code}\nclass SchemaValidation2(pan.DataFrameModel):\n    \n    id_nr: Series[str] = pan.Field(nullable=False) # Default\n    lope_id_nr: Series[str] = pan.Field(\n        str_startswith='L',\n        str_length={'min_value': 5,\n                    'max_value': 5}\n    )\n    aar: Series[str] = pan.Field(\n        str_length={'min_value': 4,\n                    'max_value': 4}\n    )\n    navn: Series[str] = pan.Field(nullable=False) # Default\n    produkt: Series[str] = pan.Field(\n        isin=['Eple', 'Banan', 'Gulrot', 'Brokkoli']\n    )\n    salgsverdi: Series[int] = pan.Field(ge=1000)\n    vekt: Series[int] = pan.Field(ge=500)\n    kostverdi: Series[int] = pan.Field(gt=700)\n\n    # Sjekke at kolonne aar er tekst med tall i seg\n    @pan.check(\"aar\",\n               # Valgfritt, men gir eget navn til regelen enn metodenavnet\n               name=\"str_isdigits\",\n               # Valgfritt, men her kan man styre feilmeldingen\n               error=\"str_not_digits\")\n    def check_isdigits(cls, s: Series[str]) -> Series[bool]:\n        return s.str.isdigit()\n\n    # En metode kan sjekke flere kolonner,\n    # her sjekker vi både kostverdi og salgsverdi.\n    # Validerer at Bananer har både høyere\n    # salgsverdi og kostverdi enn Epler\n    @pan.check(\"kostverdi\", \"salgsverdi\",\n               groupby=\"produkt\",\n               name=\"check_epler_bananer\")\n    def check_groupby(cls, grouped_value: Dict[str, Series[int]]) -> bool:\n        return grouped_value[\"Eple\"].sum() < grouped_value[\"Banan\"].sum()\n\n    # Trenger du å sjekke mer enn bare en kolonne av gangen?\n    # f.eks. at forholde mellom flere kolonner\n    # har en bestemt regel å følge?\n    # Her sjekkes at kombinasjonen for kolonnene\n    # id_nr og lope_id_nr er unike\n    @pan.dataframe_check\n    def unique_combo_idnr_lopeidnr(cls, df: pd.DataFrame) -> Series[bool]:\n        df2 = df.copy()\n        df3 = (\n            df2\n            .groupby(['id_nr', 'lope_id_nr'])\n            .agg({'aar': 'count'})\n            .rename(columns={'aar': 'duplikater'}) == 1\n        ).reset_index()\n        df2 = df2.merge(df3,\n                        on=['id_nr', 'lope_id_nr'],\n                        how='left')\n        return df2['duplikater']\n```\n:::\n\n\nSchemaet SchemaValidation2 har som vi ser nå 3 metoder;\n\n- check_isdigits som sjekker at teksten faktisk kun inneholder tall. Her sjekkes kun kolonnen aar.\n- check_groupby som grupperer verdiene i kolonnen produkt. Det sjekkes her for kolonnene kostverdi og salgsverdi. Den sjekker at summen av bananer er høyere enn summen av epler (for å gjøre noe enkelt og irrelevant).\n- de 2 første sjekkene kan kun jobbe med en kolonne av gangen, ev. en groupby på en annen kolonne med fokus på de gjeldende kolonnene en har tenkt å sjekke for. Den tredje siste sjekken er litt annerledes, for de andre sjekkene har benyttet decoratoren check, mens den siste har dataframe_check. Dette vil si at hele dataframen sendes inn, og her vil du ha full fleksibilitet til å sjekke det du måtte ønske på tvers av alle kolonner. Viktigste er at det returneres en serie(kolonne). I denne siste sjekken unique_combo_idnr_lopeidnr sjekkes det at kombinasjonen av kolonnene id_nr og lope_id_nr er unike i dataframen.\n\nIgjen kan dataene valideres;\n\n::: {#a852c938-6e12-444e-945e-3ed78e37b952 .cell execution_count=6}\n``` {.python .cell-code}\ntry:\n    valresult = SchemaValidation2.validate(data, lazy=True)\nexcept SchemaErrors as error:\n    valresult = error.failure_cases\n\nvalresult\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>schema_context</th>\n      <th>column</th>\n      <th>check</th>\n      <th>check_number</th>\n      <th>failure_case</th>\n      <th>index</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>14</th>\n      <td>DataFrameSchema</td>\n      <td>lope_id_nr</td>\n      <td>unique_combo_idnr_lopeidnr</td>\n      <td>0</td>\n      <td>L0001</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>15</th>\n      <td>DataFrameSchema</td>\n      <td>lope_id_nr</td>\n      <td>unique_combo_idnr_lopeidnr</td>\n      <td>0</td>\n      <td>L0001</td>\n      <td>9</td>\n    </tr>\n    <tr>\n      <th>26</th>\n      <td>DataFrameSchema</td>\n      <td>kostverdi</td>\n      <td>unique_combo_idnr_lopeidnr</td>\n      <td>0</td>\n      <td>5000</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>25</th>\n      <td>DataFrameSchema</td>\n      <td>vekt</td>\n      <td>unique_combo_idnr_lopeidnr</td>\n      <td>0</td>\n      <td>100</td>\n      <td>9</td>\n    </tr>\n    <tr>\n      <th>24</th>\n      <td>DataFrameSchema</td>\n      <td>vekt</td>\n      <td>unique_combo_idnr_lopeidnr</td>\n      <td>0</td>\n      <td>700</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>23</th>\n      <td>DataFrameSchema</td>\n      <td>salgsverdi</td>\n      <td>unique_combo_idnr_lopeidnr</td>\n      <td>0</td>\n      <td>3000</td>\n      <td>9</td>\n    </tr>\n    <tr>\n      <th>22</th>\n      <td>DataFrameSchema</td>\n      <td>salgsverdi</td>\n      <td>unique_combo_idnr_lopeidnr</td>\n      <td>0</td>\n      <td>7000</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>21</th>\n      <td>DataFrameSchema</td>\n      <td>produkt</td>\n      <td>unique_combo_idnr_lopeidnr</td>\n      <td>0</td>\n      <td>Agurk</td>\n      <td>9</td>\n    </tr>\n    <tr>\n      <th>20</th>\n      <td>DataFrameSchema</td>\n      <td>produkt</td>\n      <td>unique_combo_idnr_lopeidnr</td>\n      <td>0</td>\n      <td>Eple</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>19</th>\n      <td>DataFrameSchema</td>\n      <td>navn</td>\n      <td>unique_combo_idnr_lopeidnr</td>\n      <td>0</td>\n      <td>Kari</td>\n      <td>9</td>\n    </tr>\n    <tr>\n      <th>18</th>\n      <td>DataFrameSchema</td>\n      <td>navn</td>\n      <td>unique_combo_idnr_lopeidnr</td>\n      <td>0</td>\n      <td>Per</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>17</th>\n      <td>DataFrameSchema</td>\n      <td>aar</td>\n      <td>unique_combo_idnr_lopeidnr</td>\n      <td>0</td>\n      <td>2024</td>\n      <td>9</td>\n    </tr>\n    <tr>\n      <th>16</th>\n      <td>DataFrameSchema</td>\n      <td>aar</td>\n      <td>unique_combo_idnr_lopeidnr</td>\n      <td>0</td>\n      <td>2024</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>27</th>\n      <td>DataFrameSchema</td>\n      <td>kostverdi</td>\n      <td>unique_combo_idnr_lopeidnr</td>\n      <td>0</td>\n      <td>3100</td>\n      <td>9</td>\n    </tr>\n    <tr>\n      <th>13</th>\n      <td>DataFrameSchema</td>\n      <td>id_nr</td>\n      <td>unique_combo_idnr_lopeidnr</td>\n      <td>0</td>\n      <td>random-id2</td>\n      <td>9</td>\n    </tr>\n    <tr>\n      <th>12</th>\n      <td>DataFrameSchema</td>\n      <td>id_nr</td>\n      <td>unique_combo_idnr_lopeidnr</td>\n      <td>0</td>\n      <td>random-id2</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Column</td>\n      <td>lope_id_nr</td>\n      <td>str_startswith('L')</td>\n      <td>1</td>\n      <td>0001</td>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>Column</td>\n      <td>kostverdi</td>\n      <td>check_epler_bananer</td>\n      <td>1</td>\n      <td>False</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>Column</td>\n      <td>kostverdi</td>\n      <td>greater_than(700)</td>\n      <td>0</td>\n      <td>55</td>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>Column</td>\n      <td>vekt</td>\n      <td>greater_than_or_equal_to(500)</td>\n      <td>0</td>\n      <td>5</td>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>Column</td>\n      <td>vekt</td>\n      <td>greater_than_or_equal_to(500)</td>\n      <td>0</td>\n      <td>100</td>\n      <td>9</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>Column</td>\n      <td>salgsverdi</td>\n      <td>check_epler_bananer</td>\n      <td>1</td>\n      <td>False</td>\n      <td>None</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>Column</td>\n      <td>salgsverdi</td>\n      <td>greater_than_or_equal_to(1000)</td>\n      <td>0</td>\n      <td>50</td>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>Column</td>\n      <td>produkt</td>\n      <td>isin(['Eple', 'Banan', 'Gulrot', 'Brokkoli'])</td>\n      <td>0</td>\n      <td>Agurk</td>\n      <td>9</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Column</td>\n      <td>navn</td>\n      <td>not_nullable</td>\n      <td>None</td>\n      <td>None</td>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Column</td>\n      <td>aar</td>\n      <td>str_not_digits</td>\n      <td>1</td>\n      <td>2024Q1</td>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Column</td>\n      <td>aar</td>\n      <td>str_length(4, 4)</td>\n      <td>0</td>\n      <td>2024Q1</td>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>0</th>\n      <td>Column</td>\n      <td>lope_id_nr</td>\n      <td>str_length(5, 5)</td>\n      <td>0</td>\n      <td>0001</td>\n      <td>10</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nDesverre vil sjekker som gjelder hele dataframen registrere flere feil ettersom han sjekker alle kolonner for gjeldende rader. Derimot er fleksibiliteten ganske stor!\n\n## Bruk av validering i funksjonene\n\nOver til ett eksempel hvor pandera viser seg som veldig nyttig! La oss si at vi har klargjorte data klart, ihht. datatilstandene, og vi er da klare for å lage statistikkdata. Det er ikke gitt at løpet er helt rett fram mellom disse datatilstandene, men i dette eksempelet er jobben bare å få aggregert klargjorte data.\n\nNedenfor her lager jeg klargjorte data av de dataene som vi har jobbet med, og som er korrekte. Lager ett tilhørende skjema, som bare arver fra det første schemaet vi lagde. Valideringen her vil selvsagt gå smertefritt igjennom.\n\n::: {#1f16c1ab-8bc5-4eee-b0a2-3be4bb0c3b94 .cell execution_count=7}\n``` {.python .cell-code}\nklargjort_df = data.head(6)\n\n\nclass KlargjortSchema(SchemaValidation1):\n    pass\n\n\ntry:\n    klargjort_df = KlargjortSchema.validate(klargjort_df, lazy=True)\nexcept SchemaErrors as error:\n    valresult = error.failure_cases\n    raise error\n\nklargjort_df\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id_nr</th>\n      <th>lope_id_nr</th>\n      <th>aar</th>\n      <th>navn</th>\n      <th>produkt</th>\n      <th>salgsverdi</th>\n      <th>vekt</th>\n      <th>kostverdi</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>829c6ce1-817d-40f3-956d-dffb5cf9dbec</td>\n      <td>L0001</td>\n      <td>2024</td>\n      <td>Ida</td>\n      <td>Eple</td>\n      <td>2072</td>\n      <td>1420</td>\n      <td>1554</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>ed18c723-b1c8-49be-8017-aa6b9e1bbef7</td>\n      <td>L0001</td>\n      <td>2023</td>\n      <td>Ida</td>\n      <td>Eple</td>\n      <td>2624</td>\n      <td>2989</td>\n      <td>1968</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1306362a-df6b-4f66-bcbb-1f718a37a8e9</td>\n      <td>L0001</td>\n      <td>2023</td>\n      <td>Per</td>\n      <td>Eple</td>\n      <td>5751</td>\n      <td>1726</td>\n      <td>4313</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>d2667fa8-71c8-4987-8079-dd28d59f3a69</td>\n      <td>L0001</td>\n      <td>2024</td>\n      <td>Kari</td>\n      <td>Gulrot</td>\n      <td>9596</td>\n      <td>3500</td>\n      <td>7197</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>b925e792-8b16-45ce-8255-1741a9ecfb86</td>\n      <td>L0001</td>\n      <td>2023</td>\n      <td>Kari</td>\n      <td>Brokkoli</td>\n      <td>4986</td>\n      <td>2424</td>\n      <td>3739</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>999d897a-c2e0-4529-935e-956e74614463</td>\n      <td>L0001</td>\n      <td>2024</td>\n      <td>Kari</td>\n      <td>Brokkoli</td>\n      <td>5439</td>\n      <td>663</td>\n      <td>4079</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nDeretter definerer vi ett eget schema for statistikkdata, men noen tilhørende regler og datatyper;\n\n::: {#14cd0322-8947-49d7-afc5-d4eedc2ab165 .cell execution_count=8}\n``` {.python .cell-code}\nclass StatistikkSchema(pan.DataFrameModel):\n    \n    aar: Series[pd.CategoricalDtype] = pan.Field(\n        coerce=True, # Vil konvertere datatypene for meg\n        str_length={'min_value': 4,\n                    'max_value': 4})\n    produkt: Series[pd.CategoricalDtype] = pan.Field(\n        coerce=True, # Vil konvertere datatypene for meg\n        isin=['Eple', 'Banan', 'Gulrot', 'Brokkoli'])\n    salgsverdi: Series[int] = pan.Field(ge=0)\n```\n:::\n\n\nSå over til magien; Pandera schemaene kan innlemmes i hvilken som helst funksjon som har dataframes som input eller output, og det uten at du selv skriver at valideringen skal skje i funksjonen, det skjer automagisk! Og det gjøres som følgende;\n\n::: {#eb318e05-2d7e-4ab6-a833-e86b1d5eef7c .cell execution_count=9}\n``` {.python .cell-code}\n# Lazy for at valideringen skal utføres igjennom hele dataframene\n@pan.check_types(lazy=True)\ndef agg_statistikk(\n    df: DataFrame[KlargjortSchema]\n) -> DataFrame[StatistikkSchema]:\n    dff = (\n        df\n        .copy()\n        .groupby(['aar', 'produkt'], as_index=False)\n        .agg({'salgsverdi': 'sum'})\n    )\n    return dff\n```\n:::\n\n\nSå nå ved å bruke funksjonen, så vil du ikke få lagd statistikk data uten at både klargjorte data blir validert og godkjent, og at statistikk data som er på vei ut av funksjonen er validert og godkjent. I vårt tilfelle skal det gå fint nå;\n\n::: {#1cc833fe-d2cc-4a6f-8b30-711617b9791d .cell execution_count=10}\n``` {.python .cell-code}\nstatistikk_df = agg_statistikk(klargjort_df)\nstatistikk_df\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>aar</th>\n      <th>produkt</th>\n      <th>salgsverdi</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023</td>\n      <td>Brokkoli</td>\n      <td>4986</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023</td>\n      <td>Eple</td>\n      <td>8375</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2024</td>\n      <td>Brokkoli</td>\n      <td>5439</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2024</td>\n      <td>Eple</td>\n      <td>2072</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2024</td>\n      <td>Gulrot</td>\n      <td>9596</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nMan skal også kunne validere flere schemaer samtidig også hvis en ønsker det. Altså at input til funksjonen sjekkes opp mot flere schema samtidig, eller at output blir det. Det er ikke blitt demonstrert her.\n\nMed det samme kan vi sjekke datatypene, vi hadde satt at Pandera skulle endre datatypene for oss. Både før og etter;\n\n::: {#8d444b3c-f4c3-4f24-be5d-9c4bf5f041ca .cell execution_count=11}\n``` {.python .cell-code code-fold=\"true\"}\nfrom IPython.display import HTML, display\n\nkdf = pd.DataFrame(klargjort_df.dtypes, columns=['Datatyper'])\nsdf = pd.DataFrame(statistikk_df.dtypes, columns=['Datatyper'])\n\n# Style dataframes\nstyled_df1 = kdf.style.set_caption(\"Klargjorte-data\")\nstyled_df2 = sdf.style.set_caption(\"Statistikk data\")\n\ndisplay(HTML(\nf\"\"\"\n<div style=\"display: flex; justify-content: space-around;\">\n<div>{styled_df1.to_html()}</div>\n<div>{styled_df2.to_html()}</div>\n</div>\n\"\"\"\n))\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n\n<div style=\"display: flex; justify-content: space-around;\">\n<div><style type=\"text/css\">\n</style>\n<table id=\"T_f53b0\">\n  <caption>Klargjorte-data</caption>\n  <thead>\n    <tr>\n      <th class=\"blank level0\" >&nbsp;</th>\n      <th id=\"T_f53b0_level0_col0\" class=\"col_heading level0 col0\" >Datatyper</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th id=\"T_f53b0_level0_row0\" class=\"row_heading level0 row0\" >id_nr</th>\n      <td id=\"T_f53b0_row0_col0\" class=\"data row0 col0\" >object</td>\n    </tr>\n    <tr>\n      <th id=\"T_f53b0_level0_row1\" class=\"row_heading level0 row1\" >lope_id_nr</th>\n      <td id=\"T_f53b0_row1_col0\" class=\"data row1 col0\" >object</td>\n    </tr>\n    <tr>\n      <th id=\"T_f53b0_level0_row2\" class=\"row_heading level0 row2\" >aar</th>\n      <td id=\"T_f53b0_row2_col0\" class=\"data row2 col0\" >object</td>\n    </tr>\n    <tr>\n      <th id=\"T_f53b0_level0_row3\" class=\"row_heading level0 row3\" >navn</th>\n      <td id=\"T_f53b0_row3_col0\" class=\"data row3 col0\" >object</td>\n    </tr>\n    <tr>\n      <th id=\"T_f53b0_level0_row4\" class=\"row_heading level0 row4\" >produkt</th>\n      <td id=\"T_f53b0_row4_col0\" class=\"data row4 col0\" >object</td>\n    </tr>\n    <tr>\n      <th id=\"T_f53b0_level0_row5\" class=\"row_heading level0 row5\" >salgsverdi</th>\n      <td id=\"T_f53b0_row5_col0\" class=\"data row5 col0\" >int64</td>\n    </tr>\n    <tr>\n      <th id=\"T_f53b0_level0_row6\" class=\"row_heading level0 row6\" >vekt</th>\n      <td id=\"T_f53b0_row6_col0\" class=\"data row6 col0\" >int64</td>\n    </tr>\n    <tr>\n      <th id=\"T_f53b0_level0_row7\" class=\"row_heading level0 row7\" >kostverdi</th>\n      <td id=\"T_f53b0_row7_col0\" class=\"data row7 col0\" >int64</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n<div><style type=\"text/css\">\n</style>\n<table id=\"T_7e866\">\n  <caption>Statistikk data</caption>\n  <thead>\n    <tr>\n      <th class=\"blank level0\" >&nbsp;</th>\n      <th id=\"T_7e866_level0_col0\" class=\"col_heading level0 col0\" >Datatyper</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th id=\"T_7e866_level0_row0\" class=\"row_heading level0 row0\" >aar</th>\n      <td id=\"T_7e866_row0_col0\" class=\"data row0 col0\" >category</td>\n    </tr>\n    <tr>\n      <th id=\"T_7e866_level0_row1\" class=\"row_heading level0 row1\" >produkt</th>\n      <td id=\"T_7e866_row1_col0\" class=\"data row1 col0\" >category</td>\n    </tr>\n    <tr>\n      <th id=\"T_7e866_level0_row2\" class=\"row_heading level0 row2\" >salgsverdi</th>\n      <td id=\"T_7e866_row2_col0\" class=\"data row2 col0\" >int64</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n</div>\n```\n:::\n:::\n\n\n## BONUS: Auto-transformasjon av kolonneverdier\n\nPandera har noe som kalles parsers, som gir oss muligheten til å utføre preprosesseringer på dataene før validering.\nDette kan være flere typer transformasjoner som man bør sørge for er gjort før valideringen utføres, ev. om transformasjonen bare skal gjennomføres.\n\nLa oss ta ett eksempel med en liten del av dataene vi har jobbet med til nå, da med data vi vet det ikke skal bli noe problemer med;\n\n::: {#bd600d5e-b034-47e0-a86a-4aa67dbc7f2d .cell execution_count=12}\n``` {.python .cell-code}\ndata['dekningsbidrag'] = data['salgsverdi'] - data['kostverdi']\n\ndf = data.head(3).copy()\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id_nr</th>\n      <th>lope_id_nr</th>\n      <th>aar</th>\n      <th>navn</th>\n      <th>produkt</th>\n      <th>salgsverdi</th>\n      <th>vekt</th>\n      <th>kostverdi</th>\n      <th>dekningsbidrag</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>829c6ce1-817d-40f3-956d-dffb5cf9dbec</td>\n      <td>L0001</td>\n      <td>2024</td>\n      <td>Ida</td>\n      <td>Eple</td>\n      <td>2072</td>\n      <td>1420</td>\n      <td>1554</td>\n      <td>518</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>ed18c723-b1c8-49be-8017-aa6b9e1bbef7</td>\n      <td>L0001</td>\n      <td>2023</td>\n      <td>Ida</td>\n      <td>Eple</td>\n      <td>2624</td>\n      <td>2989</td>\n      <td>1968</td>\n      <td>656</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1306362a-df6b-4f66-bcbb-1f718a37a8e9</td>\n      <td>L0001</td>\n      <td>2023</td>\n      <td>Per</td>\n      <td>Eple</td>\n      <td>5751</td>\n      <td>1726</td>\n      <td>4313</td>\n      <td>1438</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nJeg beregner her dekningsbidraget for hver observasjon, som da er differansen mellom salgsverdi og kostverdi. Det er mer eller mindre en funksjon som avhenger av disse to variablene, og må holdes oppdatert.\n\nOg la oss nå si at kostverdien på første observasjonen ikke skulle være på 75 % av salgsverdi slik vi startet med, men av en eller annen grunn heller skulle være på 85 %. Vi kan editere det inn;\n\n::: {#9af23742-57a8-4f28-81ad-6f2a7e4f23fa .cell execution_count=13}\n``` {.python .cell-code}\ndf.loc[0, ['kostverdi']] = int(round(\n    df.iloc[0]['salgsverdi'] * 0.85, 0)\n                              )\n\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id_nr</th>\n      <th>lope_id_nr</th>\n      <th>aar</th>\n      <th>navn</th>\n      <th>produkt</th>\n      <th>salgsverdi</th>\n      <th>vekt</th>\n      <th>kostverdi</th>\n      <th>dekningsbidrag</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>829c6ce1-817d-40f3-956d-dffb5cf9dbec</td>\n      <td>L0001</td>\n      <td>2024</td>\n      <td>Ida</td>\n      <td>Eple</td>\n      <td>2072</td>\n      <td>1420</td>\n      <td>1761</td>\n      <td>518</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>ed18c723-b1c8-49be-8017-aa6b9e1bbef7</td>\n      <td>L0001</td>\n      <td>2023</td>\n      <td>Ida</td>\n      <td>Eple</td>\n      <td>2624</td>\n      <td>2989</td>\n      <td>1968</td>\n      <td>656</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1306362a-df6b-4f66-bcbb-1f718a37a8e9</td>\n      <td>L0001</td>\n      <td>2023</td>\n      <td>Per</td>\n      <td>Eple</td>\n      <td>5751</td>\n      <td>1726</td>\n      <td>4313</td>\n      <td>1438</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nSå nå har vi fått korrigert kostverdien på første observasjon, men dekningsbidraget er fortsatt den samme. Dette kan løses som en egen funksjon, men hvorfor ikke innlemme det i data valideringen vår, da pandera støtter slik transformering. Vi lager først ett tilhørende schema;\n\n::: {#e47acd2f-f4b9-42f7-a44d-3d299c954690 .cell execution_count=14}\n``` {.python .cell-code}\nclass ParserSchema(SchemaValidation1):\n    dekningsbidrag: Series[int]\n\n    @pan.check(\"navn\")\n    def is_uppercase(cls, s: Series[str]) -> Series[bool]:\n        return s.str.isupper()\n\n    # konverterer all tekst i kolonnen til å ha kun store bokstaver\n    @pan.parser(\"navn\")\n    def uppercase(cls, s: Series[str]) -> Series[str]:\n        return s.str.upper()\n\n    # Sørger for at dekningsbidrag blir rekalkulert\n    @pan.dataframe_parser\n    def kalkuler_dekningsbidrag(cls, df: pd.DataFrame) -> pd.DataFrame:\n        df['dekningsbidrag'] = df['salgsverdi'] - df['kostverdi']\n        return df\n```\n:::\n\n\nSå her tar jeg i bruk det aller første schema som vi definerte, men legger på dekningsbidrag som ikke har noen andre valideringer enn datatype. Med dataene vi har nå skal det ikke dukke opp noen feil med dette. Jeg legger ved en valideringsregel for navn i dette tilfelle, hvor nå alt i kolonnen navn skal være store bokstaver. Vi vet allerede at det ikke er noen store bokstaver der, så vi legger inn en metode som har decorator parser som vil transformere dette. I tillegg legger vi til en egen metode med decorator dataframe_parser for å rekalkulere dekningsbidraget.\n\nSå sånn sett skulle man kanskje tro at valideringen av kolonnen navn vil kunne slå ut i valideringen, men som nevnt så kjøres transformasjonene først før valideringen. I tillegg, når valideringen går igjennom, så vil du få dataframen du sendte inn i retur ved utførelsen av valideringen;\n\n::: {#c0fec2c0-8a4d-4928-8d10-c8535d544f1b .cell execution_count=15}\n``` {.python .cell-code}\ntry:\n    valresult = ParserSchema.validate(df, lazy=True)\nexcept SchemaErrors as error:\n    valresult = error.failure_cases\n\nvalresult\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id_nr</th>\n      <th>lope_id_nr</th>\n      <th>aar</th>\n      <th>navn</th>\n      <th>produkt</th>\n      <th>salgsverdi</th>\n      <th>vekt</th>\n      <th>kostverdi</th>\n      <th>dekningsbidrag</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>829c6ce1-817d-40f3-956d-dffb5cf9dbec</td>\n      <td>L0001</td>\n      <td>2024</td>\n      <td>IDA</td>\n      <td>Eple</td>\n      <td>2072</td>\n      <td>1420</td>\n      <td>1761</td>\n      <td>311</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>ed18c723-b1c8-49be-8017-aa6b9e1bbef7</td>\n      <td>L0001</td>\n      <td>2023</td>\n      <td>IDA</td>\n      <td>Eple</td>\n      <td>2624</td>\n      <td>2989</td>\n      <td>1968</td>\n      <td>656</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1306362a-df6b-4f66-bcbb-1f718a37a8e9</td>\n      <td>L0001</td>\n      <td>2023</td>\n      <td>PER</td>\n      <td>Eple</td>\n      <td>5751</td>\n      <td>1726</td>\n      <td>4313</td>\n      <td>1438</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nSom vi nå ser, så har valideringen gått fint for seg. Vi ser at alle verdier i kolonnen navn har blitt tekst med kun store bokstaver, og vi ser at dekningsbidraget har blitt rekalkulert så det nå er korrekt!\n\n## Oppsummering\n\nFor at vi skal kunne produsere og levere statistikk av høy kvalitet er det viktig at vi validerer data løpende i produksjonsløpene våre. Store deler av dataene våre er strukturerte, ev. tidy om du vil, og da er python pakken Pandera en sterk kandidat å benytte inn i kodene våre. Hvertfall hvis du programmerer i Python. For R så er pakken [Validate](https://github.com/data-cleaning/validate) aktuell. Her har vi introdusert generell bruk av Pandera for validering av data; hvordan definere schema og valideringsregler, hvordan validere en dataframe med det, og hvordan det kan tas i bruk i blant annet funksjoner. Trenger du hjelp til å implementere data validering med Pandera inn i koden din, så er Støtteteamene mulig å spørre, ellers kommer man ikke unna [dokumentasjonen til Pandera](https://pandera.readthedocs.io/en/stable/index.html) selv.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}